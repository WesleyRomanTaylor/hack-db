// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/brocwoodworthIBLX/hack-db/pkg/pb/service.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/brocwoodworthIBLX/hack-db/pkg/pb/service.proto

It has these top-level messages:
	Tool
	Tag
	Comment
	CreateToolRequest
	CreateToolResponse
	ListToolRequest
	ListToolResponse
	ReadToolRequest
	ReadToolResponse
	UpdateToolRequest
	UpdateToolResponse
	CreateTagRequest
	CreateTagResponse
	ListTagRequest
	ListTagResponse
	ReadTagRequest
	ReadTagResponse
	CreateCommentRequest
	CreateCommentResponse
	ListCommentRequest
	ListCommentResponse
	ReadCommentRequest
	ReadCommentResponse
*/
package pb

import context "context"
import fmt "fmt"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import go_uuid1 "github.com/satori/go.uuid"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ToolORM struct {
	BrokenCount int32
	CreatedBy   string
	Description string
	Id          *go_uuid1.UUID
	Title       string
	ToolCode    string
	VoteCount   int32
}

// TableName overrides the default tablename generated by GORM
func (ToolORM) TableName() string {
	return "tools"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tool) ToORM(ctx context.Context) (ToolORM, error) {
	to := ToolORM{}
	var err error
	if prehook, ok := interface{}(m).(ToolWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	to.Title = m.Title
	to.ToolCode = m.ToolCode
	to.CreatedBy = m.CreatedBy
	to.Description = m.Description
	// Repeated type []string is not an ORMable message type
	to.VoteCount = m.VoteCount
	to.BrokenCount = m.BrokenCount
	if posthook, ok := interface{}(m).(ToolWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ToolORM) ToPB(ctx context.Context) (Tool, error) {
	to := Tool{}
	var err error
	if prehook, ok := interface{}(m).(ToolWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	to.Title = m.Title
	to.ToolCode = m.ToolCode
	to.CreatedBy = m.CreatedBy
	to.Description = m.Description
	// Repeated type []string is not an ORMable message type
	to.VoteCount = m.VoteCount
	to.BrokenCount = m.BrokenCount
	if posthook, ok := interface{}(m).(ToolWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tool the arg will be the target, the caller the one being converted from

// ToolBeforeToORM called before default ToORM code
type ToolWithBeforeToORM interface {
	BeforeToORM(context.Context, *ToolORM) error
}

// ToolAfterToORM called after default ToORM code
type ToolWithAfterToORM interface {
	AfterToORM(context.Context, *ToolORM) error
}

// ToolBeforeToPB called before default ToPB code
type ToolWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tool) error
}

// ToolAfterToPB called after default ToPB code
type ToolWithAfterToPB interface {
	AfterToPB(context.Context, *Tool) error
}

type TagORM struct {
	Id   *go_uuid1.UUID
	Name string
}

// TableName overrides the default tablename generated by GORM
func (TagORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tag) ToORM(ctx context.Context) (TagORM, error) {
	to := TagORM{}
	var err error
	if prehook, ok := interface{}(m).(TagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	to.Name = m.Name
	// Repeated type []*gorm_types.UUIDValue is not an ORMable message type
	if posthook, ok := interface{}(m).(TagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagORM) ToPB(ctx context.Context) (Tag, error) {
	to := Tag{}
	var err error
	if prehook, ok := interface{}(m).(TagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	to.Name = m.Name
	// Repeated type []*gorm_types.UUIDValue is not an ORMable message type
	if posthook, ok := interface{}(m).(TagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tag the arg will be the target, the caller the one being converted from

// TagBeforeToORM called before default ToORM code
type TagWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagORM) error
}

// TagAfterToORM called after default ToORM code
type TagWithAfterToORM interface {
	AfterToORM(context.Context, *TagORM) error
}

// TagBeforeToPB called before default ToPB code
type TagWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tag) error
}

// TagAfterToPB called after default ToPB code
type TagWithAfterToPB interface {
	AfterToPB(context.Context, *Tag) error
}

type CommentORM struct {
	Comment   string
	CreatedBy string
	Id        *go_uuid1.UUID
	ToolId    *go_uuid1.UUID
}

// TableName overrides the default tablename generated by GORM
func (CommentORM) TableName() string {
	return "comments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Comment) ToORM(ctx context.Context) (CommentORM, error) {
	to := CommentORM{}
	var err error
	if prehook, ok := interface{}(m).(CommentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	to.Comment = m.Comment
	to.CreatedBy = m.CreatedBy
	if m.ToolId != nil {
		tempUUID, uErr := go_uuid1.FromString(m.ToolId.Value)
		if uErr != nil {
			return to, uErr
		}
		to.ToolId = &tempUUID
	}
	if posthook, ok := interface{}(m).(CommentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CommentORM) ToPB(ctx context.Context) (Comment, error) {
	to := Comment{}
	var err error
	if prehook, ok := interface{}(m).(CommentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	to.Comment = m.Comment
	to.CreatedBy = m.CreatedBy
	if m.ToolId != nil {
		to.ToolId = &types1.UUIDValue{Value: m.ToolId.String()}
	}
	if posthook, ok := interface{}(m).(CommentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Comment the arg will be the target, the caller the one being converted from

// CommentBeforeToORM called before default ToORM code
type CommentWithBeforeToORM interface {
	BeforeToORM(context.Context, *CommentORM) error
}

// CommentAfterToORM called after default ToORM code
type CommentWithAfterToORM interface {
	AfterToORM(context.Context, *CommentORM) error
}

// CommentBeforeToPB called before default ToPB code
type CommentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Comment) error
}

// CommentAfterToPB called after default ToPB code
type CommentWithAfterToPB interface {
	AfterToPB(context.Context, *Comment) error
}

// DefaultCreateTool executes a basic gorm create call
func DefaultCreateTool(ctx context.Context, in *Tool, db *gorm1.DB) (*Tool, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ToolORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTool executes a basic gorm read call
func DefaultReadTool(ctx context.Context, in *Tool, db *gorm1.DB) (*Tool, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ToolORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ToolORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ToolORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ToolORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTool(ctx context.Context, in *Tool, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ToolORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ToolORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteToolSet(ctx context.Context, in []*Tool, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ToolORM{})).(ToolORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ToolORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ToolORM{})).(ToolORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ToolORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tool, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tool, *gorm1.DB) error
}

// DefaultStrictUpdateTool clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTool(ctx context.Context, in *Tool, db *gorm1.DB) (*Tool, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTool")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ToolORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ToolORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ToolORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTool executes a basic gorm update call with patch behavior
func DefaultPatchTool(ctx context.Context, in *Tool, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Tool, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Tool
	var err error
	if hook, ok := interface{}(&pbObj).(ToolWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTool(ctx, &Tool{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ToolWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTool(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ToolWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTool(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ToolWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ToolWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tool, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ToolWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tool, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ToolWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tool, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ToolWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tool, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTool executes a bulk gorm update call with patch behavior
func DefaultPatchSetTool(ctx context.Context, objects []*Tool, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Tool, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tool, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTool(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTool patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTool(ctx context.Context, patchee *Tool, patcher *Tool, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Tool, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"ToolCode" {
			patchee.ToolCode = patcher.ToolCode
			continue
		}
		if f == prefix+"CreatedBy" {
			patchee.CreatedBy = patcher.CreatedBy
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"VoteCount" {
			patchee.VoteCount = patcher.VoteCount
			continue
		}
		if f == prefix+"BrokenCount" {
			patchee.BrokenCount = patcher.BrokenCount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTool executes a gorm list call
func DefaultListTool(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Tool, error) {
	in := Tool{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ToolORM{}, &Tool{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ToolORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tool{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ToolORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ToolORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ToolORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ToolORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateTag executes a basic gorm create call
func DefaultCreateTag(ctx context.Context, in *Tag, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTag executes a basic gorm read call
func DefaultReadTag(ctx context.Context, in *Tag, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTag(ctx context.Context, in *Tag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TagORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteTagSet(ctx context.Context, in []*Tag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagORM{})).(TagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagORM{})).(TagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tag, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tag, *gorm1.DB) error
}

// DefaultStrictUpdateTag clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTag(ctx context.Context, in *Tag, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TagORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTag executes a basic gorm update call with patch behavior
func DefaultPatchTag(ctx context.Context, in *Tag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Tag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Tag
	var err error
	if hook, ok := interface{}(&pbObj).(TagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTag(ctx, &Tag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTag executes a bulk gorm update call with patch behavior
func DefaultPatchSetTag(ctx context.Context, objects []*Tag, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Tag, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tag, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTag(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTag(ctx context.Context, patchee *Tag, patcher *Tag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Tag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ToolId" {
			patchee.ToolId = patcher.ToolId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTag executes a gorm list call
func DefaultListTag(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Tag, error) {
	in := Tag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TagORM{}, &Tag{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type TagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type TagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TagORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateComment executes a basic gorm create call
func DefaultCreateComment(ctx context.Context, in *Comment, db *gorm1.DB) (*Comment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CommentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadComment executes a basic gorm read call
func DefaultReadComment(ctx context.Context, in *Comment, db *gorm1.DB) (*Comment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &CommentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CommentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CommentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CommentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteComment(ctx context.Context, in *Comment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CommentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CommentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteCommentSet(ctx context.Context, in []*Comment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CommentORM{})).(CommentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CommentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CommentORM{})).(CommentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CommentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Comment, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Comment, *gorm1.DB) error
}

// DefaultStrictUpdateComment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateComment(ctx context.Context, in *Comment, db *gorm1.DB) (*Comment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateComment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CommentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CommentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchComment executes a basic gorm update call with patch behavior
func DefaultPatchComment(ctx context.Context, in *Comment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Comment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Comment
	var err error
	if hook, ok := interface{}(&pbObj).(CommentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadComment(ctx, &Comment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CommentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskComment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CommentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateComment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CommentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CommentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Comment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CommentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Comment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CommentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Comment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CommentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Comment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetComment executes a bulk gorm update call with patch behavior
func DefaultPatchSetComment(ctx context.Context, objects []*Comment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Comment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Comment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchComment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskComment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskComment(ctx context.Context, patchee *Comment, patcher *Comment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Comment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"CreatedBy" {
			patchee.CreatedBy = patcher.CreatedBy
			continue
		}
		if f == prefix+"ToolId" {
			patchee.ToolId = patcher.ToolId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListComment executes a gorm list call
func DefaultListComment(ctx context.Context, db *gorm1.DB) ([]*Comment, error) {
	in := Comment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CommentORM{}, &Comment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CommentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Comment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CommentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CommentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CommentORM) error
}
type ToolsDefaultServer struct {
}

// Create ...
func (m *ToolsDefaultServer) Create(ctx context.Context, in *CreateToolRequest) (*CreateToolResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ToolsToolWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateTool(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateToolResponse{Result: res}
	if custom, ok := interface{}(in).(ToolsToolWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ToolsToolWithBeforeCreate called before DefaultCreateTool in the default Create handler
type ToolsToolWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ToolsToolWithAfterCreate called before DefaultCreateTool in the default Create handler
type ToolsToolWithAfterCreate interface {
	AfterCreate(context.Context, *CreateToolResponse, *gorm1.DB) error
}

// Update ...
func (m *ToolsDefaultServer) Update(ctx context.Context, in *UpdateToolRequest) (*UpdateToolResponse, error) {
	var err error
	var res *Tool
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ToolsToolWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateTool(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateToolResponse{Result: res}
	if custom, ok := interface{}(in).(ToolsToolWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ToolsToolWithBeforeUpdate called before DefaultUpdateTool in the default Update handler
type ToolsToolWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ToolsToolWithAfterUpdate called before DefaultUpdateTool in the default Update handler
type ToolsToolWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateToolResponse, *gorm1.DB) error
}

// Read ...
func (m *ToolsDefaultServer) Read(ctx context.Context, in *ReadToolRequest) (*ReadToolResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ToolsToolWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadTool(ctx, &Tool{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadToolResponse{Result: res}
	if custom, ok := interface{}(in).(ToolsToolWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ToolsToolWithBeforeRead called before DefaultReadTool in the default Read handler
type ToolsToolWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ToolsToolWithAfterRead called before DefaultReadTool in the default Read handler
type ToolsToolWithAfterRead interface {
	AfterRead(context.Context, *ReadToolResponse, *gorm1.DB) error
}

// List ...
func (m *ToolsDefaultServer) List(ctx context.Context, in *ListToolRequest) (*ListToolResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ToolsToolWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListTool(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListToolResponse{Results: res}
	if custom, ok := interface{}(in).(ToolsToolWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ToolsToolWithBeforeList called before DefaultListTool in the default List handler
type ToolsToolWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ToolsToolWithAfterList called before DefaultListTool in the default List handler
type ToolsToolWithAfterList interface {
	AfterList(context.Context, *ListToolResponse, *gorm1.DB) error
}
type TagsDefaultServer struct {
}

// Create ...
func (m *TagsDefaultServer) Create(ctx context.Context, in *CreateTagRequest) (*CreateTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(TagsTagWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateTagResponse{Result: res}
	if custom, ok := interface{}(in).(TagsTagWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// TagsTagWithBeforeCreate called before DefaultCreateTag in the default Create handler
type TagsTagWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// TagsTagWithAfterCreate called before DefaultCreateTag in the default Create handler
type TagsTagWithAfterCreate interface {
	AfterCreate(context.Context, *CreateTagResponse, *gorm1.DB) error
}

// List ...
func (m *TagsDefaultServer) List(ctx context.Context, in *ListTagRequest) (*ListTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(TagsTagWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListTag(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListTagResponse{Results: res}
	if custom, ok := interface{}(in).(TagsTagWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// TagsTagWithBeforeList called before DefaultListTag in the default List handler
type TagsTagWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// TagsTagWithAfterList called before DefaultListTag in the default List handler
type TagsTagWithAfterList interface {
	AfterList(context.Context, *ListTagResponse, *gorm1.DB) error
}

// Read ...
func (m *TagsDefaultServer) Read(ctx context.Context, in *ReadTagRequest) (*ReadTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(TagsTagWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadTag(ctx, &Tag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadTagResponse{Result: res}
	if custom, ok := interface{}(in).(TagsTagWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// TagsTagWithBeforeRead called before DefaultReadTag in the default Read handler
type TagsTagWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// TagsTagWithAfterRead called before DefaultReadTag in the default Read handler
type TagsTagWithAfterRead interface {
	AfterRead(context.Context, *ReadTagResponse, *gorm1.DB) error
}
type CommentsDefaultServer struct {
}

// Create ...
func (m *CommentsDefaultServer) Create(ctx context.Context, in *CreateCommentRequest) (*CreateCommentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CommentsCommentWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateComment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateCommentResponse{Result: res}
	if custom, ok := interface{}(in).(CommentsCommentWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CommentsCommentWithBeforeCreate called before DefaultCreateComment in the default Create handler
type CommentsCommentWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CommentsCommentWithAfterCreate called before DefaultCreateComment in the default Create handler
type CommentsCommentWithAfterCreate interface {
	AfterCreate(context.Context, *CreateCommentResponse, *gorm1.DB) error
}

// List ...
func (m *CommentsDefaultServer) List(ctx context.Context, in *ListCommentRequest) (*ListCommentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CommentsCommentWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListComment(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListCommentResponse{Results: res}
	if custom, ok := interface{}(in).(CommentsCommentWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CommentsCommentWithBeforeList called before DefaultListComment in the default List handler
type CommentsCommentWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CommentsCommentWithAfterList called before DefaultListComment in the default List handler
type CommentsCommentWithAfterList interface {
	AfterList(context.Context, *ListCommentResponse, *gorm1.DB) error
}

// Read ...
func (m *CommentsDefaultServer) Read(ctx context.Context, in *ReadCommentRequest) (*ReadCommentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CommentsCommentWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadComment(ctx, &Comment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadCommentResponse{Result: res}
	if custom, ok := interface{}(in).(CommentsCommentWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CommentsCommentWithBeforeRead called before DefaultReadComment in the default Read handler
type CommentsCommentWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CommentsCommentWithAfterRead called before DefaultReadComment in the default Read handler
type CommentsCommentWithAfterRead interface {
	AfterRead(context.Context, *ReadCommentResponse, *gorm1.DB) error
}
